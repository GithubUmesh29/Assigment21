<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	/*
	1. Often we have nested functions in which we would like to preserve the context of this from its lexical scope. An example is shown below:  function Person(name) { 
    this.name = name; } Person.prototype.prefixName = function (arr) {     return arr.map(function (character) { 
        return this.name + character; 
    }, this); 
}; 
Using Arrow Functions, the lexical value of this isn't shadowed. So re-write the above code using arrow function. 
 
	*/
	function Person(name){
		this.name=name;
		console.log(`${this.name} is my Name`);
	}

	Person.prototype.prefixName = function(arr) {
		return arr.map(character =>this.name + character);
	};
Person()

/*
2.Create Object destructuring for user where user has: 1. First Name, 2. Last Name, 3. Date of Birth, then assign this object in other object like: let obj = { first: 'Avnesh', last: 'Shakya' }; 

let {first: f, last: l} = obj; 
Then use this object in other function to display full name with date of birth. 

Definetion - Destructuring is a convenient way of extracting multiple values from data stored in (possibly nested) objects and Arrays. It can be used in locations that receive data (such as the left-hand side of an assignment). How to extract the values is specified via patterns (read on for examples).
*/

let obj = { first:'Umesh', last:'Brahmankar' };
let { first: f, last: l } = obj;
function GetName(first,last){

	console.log(`${f} ${l} Age 29`)
}

GetName(obj);


/*
3.  Create Array destructuring (which works for all iterable values) where you have all your friends name then console one by one all separately. 
 var foo = ["one", "two", "three"]; 
var [one, two, three] = foo; 
console.log(one); // "one" 
*/

let friends = ["Moiz", "Vivian", "Shrikanth", "Rohan"];

let [first, second, third, fourth] = friends;

console.log(first);
console.log(second);
console.log(third);
console.log(fourth);
/*
4. Replace IIFEs with Blocks, For example: 
 (function () {   var food = 'Meow Mix'; }() ); 
console.log(food); // Reference Error 
So same create block object where define Userâ€™s detail and  try to excess from outside of block and inside also. 


It's called an IIFE, which stands for immediately invoked function expression.

*/
//Using ES6
{
    let food = 'Meow Mix';
};

console.log(food); // Uncaught ReferenceError: food is not defined at <anonymous>:5:13

</script>
</body>
</html>